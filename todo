-series
    need to create a special class for series (probably a child of mul, which
    wouuld only accept polynoms of one variable), which would implement
    multiplication, adding etc. copy from ginac. can neglect higher terms, so
    it should be pretty fast. otherwise it's going to be slow. 
    but try first without it, if it works.
    seems to work - implement mrv
    need to implement bottom up series expansion. the topdown approach in basic
    is a backup. it seems to work for mul and pow. anything else needed?
-limits - at least mrv
-test numbers, especially reals
-printing: 2+-x
-Evaluate after every op (in doadd, domul etc.) - no, because it would be slow
    image long lists like a+b+a+b+a+b+a+b, it is faster to evaluate at once
    also we want to be able to read the expression as fast as possible and
    return something, we can play with it later.
    on the other hand - from the user point of view - he shouldn't be forced to
    call eval() at all. it should be called automatically in methods like
    isequal() etc. check how ginac is doing it - at which moment exactly it is
    calling the eval()

    policy: do not eval() in construtors add(), mul(), pow() ...., 
      do however eval in other functions like ==, !=, diff, so that the user
      don't have to know about eval() at all
      user should call: *,/,==,!= - those use eval()
      in the library we can use both == (does eval) and isequal (doesn't do
      eval)

    why: sometimes, we don't want to automatically run eval, when we know it
    would only slow down things. the user however should never know about such
    things. 

    we should decide, which functions should return evaluated expressions, and
    which not - and say that in clear.

    decision: 
    don't run eval():   add(), mul(), pow(), isequal()  
    run eval() on all input parameters plus return evaluated result:
       all the other methods

    what about exp(a+b) and ln(a*b)?  right now,
    I am doing ln(a*b) in eval(), but sometimes, I *don't* want to expand
    exp(a+b) - e.g. in limits.py. maybe move to expand()? look at mathematica,
    maple, what they are doing. the same in series expansion. needs to be
    specified. I am rather skeptical, I don't want eval() to do any magic.
    my conclusion now i that ln(a*b) and exp(a+b) should be rewritten on
    expand(), but not to eval().

-should s.symbol("x") and another s.symbol("x") be equal or not?
    need to fix hashes for that. ginac: no, maple/mathematica: yes? 
    I think it should be equal, because s.exp(x) and s.exp(x) for the same x,
    but different exp is equal. so even the symbols should do the same.
    it is confusing anyway. we should add an option to create unnamed symbol,
    which some serial number, so that it is unique, but the user is unable to
    create a symbol with the same name. this is useful in computations.

- rewrite tests, so that they are written from the users point of view. i.e.,
  write them, as we would like to use the library. Particularly, tests should
  be independent on the way we print results using str(), because this can be
  changed (check this only in 1 test regarding str()). They should also be
  independent on when we call eval(). The user just wants sympy to work, he's
  not interested in such a low level stuff.

- objects could remember a pointer to evaluated self. so that next time they
  just return the pointer. maybe also there could be a huge database (dict) of
  hashes and evaluated objs. (memory intensive probably)

- fix the symbols clutter in limits.py, using something like symbol(), or
  dummy()....

- limits: ln(w)=-x ..., see page 111. write a test case and implement

- go through the series expansion and make sure the correct amount of terms are
  being generated.

- add plus and minus infty, sign(x) doesn't work for -infty...

- problems with expressions like (sqrt(2)+1)/3, it is a number in fact, but
  not a class "number". look through all the assertions isinstance(rational),
  and consider changing it to "not has(e,x)", or rather "not e.has(x)".

- implement evalf() and implement <>, i.e. 0< ln(3)/ln(2)-1, at the beginning,
  use evalf() for the comparison.
