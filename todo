-series
    need to create a special class for series (probably a child of mul, which
    wouuld only accept polynoms of one variable), which would implement
    multiplication, adding etc. copy from ginac. can neglect higher terms, so
    it should be pretty fast. otherwise it's going to be slow. 
    but try first without it, if it works.
    seems to work - implement mrv
    need to implement bottom up series expansion. the topdown approach in basic
    is a backup. it seems to work for mul and pow. anything else needed?
-limits - at least mrv
-test numbers, especially reals
-printing: 2+-x
-Evaluate after every op (in doadd, domul etc.) - no, because it would be slow
    image long lists like a+b+a+b+a+b+a+b, it is faster to evaluate at once
    also we want to be able to read the expression as fast as possible and
    return something, we can play with it later.
    on the other hand - from the user point of view - he shouldn't be forced to
    call eval() at all. it should be called automatically in methods like
    isequal() etc. check how ginac is doing it - at which moment exactly it is
    calling the eval()

    policy: do not eval() in construtors add(), mul(), pow() ...., 
      do however eval in other functions like ==, !=, diff, so that the user
      don't have to know about eval() at all
      user should call: *,/,==,!= - those use eval()
      in the library we can use both == (does eval) and isequal (doesn't do
      eval)

    why: sometimes, we don't want to automatically run eval, when we know it
    would only slow down things. the user however should never know about such
    things. 

    we should decide, which functions should return evaluated expressions, and
    which not - and say that in clear.

    decision: 
    don't run eval():   add(), mul(), pow(), isequal()  
    run eval() on all input parameters plus return evaluated result:
       all the other methods

-move tests from unittest (test.py) to py.test (test_*) framework
-check orig.py - everything should be moved by know. delete it.
-should s.symbol("x") and another s.symbol("x") be equal or not?
    need to fix hashes for that. ginac: no, maple/mathematica: yes? 
    I think it should be equal, because s.exp(x) and s.exp(x) for the same x,
    but different exp is equal. so even the symbols should do the same.
    it is confusing anyway. we should add an option to create unnamed symbol,
    which some serial number, so that it is unique, but the user is unable to
    create a symbol with the same name. this is useful in computations.

- cmp() write comparisons, overload  ==
